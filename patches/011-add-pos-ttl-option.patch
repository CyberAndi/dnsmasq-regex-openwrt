diff --git a/dnsmasq.conf.example b/dnsmasq.conf.example
index 8b5934f..2304e37 100644
--- a/dnsmasq.conf.example
+++ b/dnsmasq.conf.example
@@ -555,6 +555,11 @@
 # seconds) here.
 #local-ttl=
 
+# Basically the same as neg-ttl, but it enforces a minimum ttl.
+# I recommend pos-ttl=300 (ie: 5 minutes), but setting it as high as
+# 86400 (1 day) shouldn't present any problems for most uses.
+#pos-ttl=
+
 # If you want dnsmasq to detect attempts by Verisign to send queries
 # to unregistered .com and .net hosts to its sitefinder service and
 # have dnsmasq instead return the correct NXDOMAIN response, uncomment
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index 0f5eb56..9c6809e 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -935,7 +935,7 @@ extern struct daemon {
   int max_logs;  /* queue limit */
   int cachesize, ftabsize;
   int port, query_port, min_port;
-  unsigned long local_ttl, neg_ttl, max_ttl, max_cache_ttl, auth_ttl;
+  unsigned long local_ttl, neg_ttl, max_ttl, max_cache_ttl, auth_ttl, pos_ttl;
   struct hostsfile *addn_hosts;
   struct dhcp_context *dhcp, *dhcp6;
   struct ra_interface *ra_interfaces;
diff --git a/src/option.c b/src/option.c
index d695355..746c87b 100644
--- a/src/option.c
+++ b/src/option.c
@@ -148,6 +148,7 @@ struct myoption {
 #define LOPT_DNSSEC_TIME   336
 #define LOPT_SPURIOUS_FILE 337
 #define LOPT_SPURIOUS_IP   338
+#define LOPT_POSTTL        339
 
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -253,6 +254,7 @@ static const struct myoption opts[] =
     { "dhcp-match", 1, 0, LOPT_MATCH }, 
     { "dhcp-broadcast", 2, 0, LOPT_BROADCAST },
     { "neg-ttl", 1, 0, LOPT_NEGTTL },
+    { "pos-ttl", 1, 0, LOPT_POSTTL },
     { "max-ttl", 1, 0, LOPT_MAXTTL },
     { "max-cache-ttl", 1, 0, LOPT_MAXCTTL },
     { "dhcp-alternate-port", 2, 0, LOPT_ALTPORT },
@@ -369,6 +371,7 @@ static struct {
   { 't', ARG_ONE, "<host_name>", gettext_noop("Specify default target in an MX record."), NULL },
   { 'T', ARG_ONE, "<integer>", gettext_noop("Specify time-to-live in seconds for replies from /etc/hosts."), NULL },
   { LOPT_NEGTTL, ARG_ONE, "<integer>", gettext_noop("Specify time-to-live in seconds for negative caching."), NULL },
+  { LOPT_POSTTL, ARG_ONE, "<integer>", gettext_noop("Specify the minimum time-to-live in seconds for all dns caching."), NULL },
   { LOPT_MAXTTL, ARG_ONE, "<integer>", gettext_noop("Specify time-to-live in seconds for maximum TTL to send to clients."), NULL },
   { 'u', ARG_ONE, "<username>", gettext_noop("Change to this user after startup. (defaults to %s)."), CHUSER }, 
   { 'U', ARG_DUP, "set:<tag>,<class>", gettext_noop("Map DHCP vendor class to tag."), NULL },
@@ -2412,6 +2415,7 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
       
     case 'T':         /* --local-ttl */
     case LOPT_NEGTTL: /* --neg-ttl */
+    case LOPT_POSTTL: /* --pos-ttl */
     case LOPT_MAXTTL: /* --max-ttl */
     case LOPT_MAXCTTL: /* --max-cache-ttl */
     case LOPT_AUTHTTL: /* --auth-ttl */
@@ -2419,6 +2423,8 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
 	int ttl;
 	if (!atoi_check(arg, &ttl))
 	  ret_err(gen_err);
+	else if (option == LOPT_POSTTL)
+	  daemon->pos_ttl = (unsigned long)ttl;
 	else if (option == LOPT_NEGTTL)
 	  daemon->neg_ttl = (unsigned long)ttl;
 	else if (option == LOPT_MAXTTL)
diff --git a/src/rfc1035.c b/src/rfc1035.c
index 9f6ced3..eb1d9e7 100644
--- a/src/rfc1035.c
+++ b/src/rfc1035.c
@@ -999,6 +999,7 @@ int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t
 			  goto cname_loop;
 			}
 		      
+                      if ((daemon->pos_ttl > 0) && (cttl < daemon->pos_ttl)) cttl = daemon->pos_ttl;
 		      cache_insert(name, &addr, now, cttl, name_encoding | secflag | F_REVERSE);
 		      found = 1; 
 		    }
@@ -1017,7 +1018,10 @@ int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t
 		  ttl = find_soa(header, qlen, NULL, doctored);
 		}
 	      if (ttl)
-		cache_insert(NULL, &addr, now, ttl, name_encoding | F_REVERSE | F_NEG | flags | secflag);	
+                {
+                  if ((daemon->pos_ttl > 0) && (ttl < daemon->pos_ttl)) ttl = daemon->pos_ttl;
+		  cache_insert(NULL, &addr, now, ttl, name_encoding | F_REVERSE | F_NEG | flags);
+                }
 	    }
 	}
       else
@@ -1067,6 +1071,7 @@ int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t
 		    {
 		      if (!cname_count--)
 			return 0; /* looped CNAMES */
+                          if ((daemon->pos_ttl > 0) && (attl < daemon->pos_ttl)) attl = daemon->pos_ttl;
 		      newc = cache_insert(name, NULL, now, attl, F_CNAME | F_FORWARD | secflag);
 		      if (newc)
 			{
@@ -1124,6 +1129,7 @@ int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t
                                   ((u8 *)&addr.addr.addr4)[3]);
                         return -1;
                       }
+                          if ((daemon->pos_ttl > 0) && (attl < daemon->pos_ttl)) attl = daemon->pos_ttl;
 		      newc = cache_insert(name, &addr, now, attl, flags | F_FORWARD | secflag);
 		      if (newc && cpp)
 			{
@@ -1150,7 +1156,9 @@ int extract_addresses(struct dns_header *header, size_t qlen, char *name, time_t
 		 pointing at this, inherit its TTL */
 	      if (ttl || cpp)
 		{
-		  newc = cache_insert(name, NULL, now, ttl ? ttl : cttl, F_FORWARD | F_NEG | flags | secflag);	
+                  if (!ttl) ttl = cttl;
+                  if ((daemon->pos_ttl > 0) && (ttl < daemon->pos_ttl)) ttl = daemon->pos_ttl;
+		  newc = cache_insert(name, NULL, now, ttl, F_FORWARD | F_NEG | flags | secflag);	
 		  if (newc && cpp)
 		    {
 		      cpp->addr.cname.target.cache = newc;
@@ -1324,6 +1332,7 @@ int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name,
 		/* Found a bogus address. Insert that info here, since there no SOA record
 		   to get the ttl from in the normal processing */
 		cache_start_insert();
+              if ((daemon->pos_ttl > 0) && (ttl < daemon->pos_ttl)) ttl = daemon->pos_ttl;
 		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);
 		cache_end_insert();
 		
